// This file is @generated by prost-build.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Gateserver {
    #[prost(int64, tag = "10")]
    pub ggebffojfoi: i64,
    #[prost(string, tag = "1969")]
    pub hocmaflgeoa: ::prost::alloc::string::String,
    #[prost(bool, tag = "1202")]
    pub unk1: bool,
    #[prost(string, repeated, tag = "349")]
    pub deneifflcma: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, tag = "1699")]
    pub pgcmeddbdch: ::prost::alloc::string::String,
    #[prost(string, tag = "1609")]
    pub lmamanegbbn: ::prost::alloc::string::String,
    #[prost(string, tag = "1725")]
    pub fgnndfalbln: ::prost::alloc::string::String,
    #[prost(string, tag = "789")]
    pub lpfhmneopol: ::prost::alloc::string::String,
    #[prost(string, tag = "1663")]
    pub galkkoiljgj: ::prost::alloc::string::String,
    #[prost(string, tag = "1837")]
    pub amkdaaaefom: ::prost::alloc::string::String,
    #[prost(string, tag = "5")]
    pub ieodbfnbpce: ::prost::alloc::string::String,
    #[prost(uint32, tag = "900")]
    pub nnjkidddaca: u32,
    #[prost(string, tag = "539")]
    pub idlpmplagme: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub ex_resource_url: ::prost::alloc::string::String,
    #[prost(bool, tag = "13")]
    pub unk2: bool,
    #[prost(uint32, tag = "15")]
    pub port: u32,
    #[prost(string, tag = "1443")]
    pub pdpjjpcpgog: ::prost::alloc::string::String,
    #[prost(uint32, tag = "1377")]
    pub jgonjgpgmai: u32,
    #[prost(string, tag = "745")]
    pub iafcgifnncg: ::prost::alloc::string::String,
    #[prost(string, tag = "805")]
    pub gnbdmeiebog: ::prost::alloc::string::String,
    #[prost(bool, tag = "1482")]
    pub unk3: bool,
    #[prost(uint32, tag = "1")]
    pub retcode: u32,
    #[prost(bool, tag = "647")]
    pub unk4: bool,
    #[prost(string, tag = "838")]
    pub cdlnbndddfj: ::prost::alloc::string::String,
    #[prost(bool, tag = "8")]
    pub unk5: bool,
    #[prost(string, tag = "1859")]
    pub ifix_url: ::prost::alloc::string::String,
    #[prost(bool, tag = "263")]
    pub unk6: bool,
    #[prost(string, tag = "2")]
    pub ip: ::prost::alloc::string::String,
    #[prost(string, tag = "14")]
    pub asset_bundle_url: ::prost::alloc::string::String,
    #[prost(string, tag = "197")]
    pub gdfkcejfimo: ::prost::alloc::string::String,
    #[prost(bool, tag = "1033")]
    pub unk7: bool,
    #[prost(bool, tag = "116")]
    pub use_tcp: bool,
    #[prost(string, tag = "7")]
    pub lua_url: ::prost::alloc::string::String,
    #[prost(string, tag = "1121")]
    pub jfkldioionh: ::prost::alloc::string::String,
    #[prost(bool, tag = "397")]
    pub unk9: bool,
    #[prost(string, tag = "1836")]
    pub ngbhmfoledl: ::prost::alloc::string::String,
    #[prost(bool, tag = "1368")]
    pub unk10: bool,
    #[prost(string, tag = "264")]
    pub edfhdalmaaf: ::prost::alloc::string::String,
    #[prost(string, tag = "829")]
    pub nffaihjplal: ::prost::alloc::string::String,
    #[prost(string, tag = "194")]
    pub idgefnfdfdj: ::prost::alloc::string::String,
    #[prost(string, tag = "87")]
    pub hmmlpdepaah: ::prost::alloc::string::String,
    #[prost(string, tag = "1394")]
    pub bdkcfbjplhd: ::prost::alloc::string::String,
    #[prost(string, tag = "1103")]
    pub nedoaabgifp: ::prost::alloc::string::String,
    #[prost(string, tag = "97")]
    pub djbceejcpad: ::prost::alloc::string::String,
    #[prost(string, tag = "181")]
    pub bbkknoodlcm: ::prost::alloc::string::String,
    #[prost(string, tag = "505")]
    pub lua_version: ::prost::alloc::string::String,
    #[prost(string, tag = "1841")]
    pub mhnmehekcdg: ::prost::alloc::string::String,
    #[prost(string, tag = "1118")]
    pub edegoipbplm: ::prost::alloc::string::String,
    #[prost(uint32, tag = "12")]
    pub lenedjnhjmj: u32,
    #[prost(string, tag = "11")]
    pub msg: ::prost::alloc::string::String,
    #[prost(string, tag = "2019")]
    pub cbollhmcbha: ::prost::alloc::string::String,
    #[prost(bool, tag = "908")]
    pub unk11: bool,
    #[prost(bool, tag = "1436")]
    pub unk12: bool,
    #[prost(uint32, tag = "904")]
    pub iefgpeckccp: u32,
    #[prost(string, tag = "1621")]
    pub pnfcemakiha: ::prost::alloc::string::String,
    #[prost(int64, tag = "9")]
    pub edikgmjkmic: i64,
    #[prost(string, tag = "1965")]
    pub mmdbkmgecee: ::prost::alloc::string::String,
    #[prost(string, tag = "6")]
    pub dpiipkocgdl: ::prost::alloc::string::String,
    #[prost(bool, tag = "164")]
    pub unk13: bool,
    #[prost(bool, tag = "790")]
    pub unk14: bool,
    #[prost(uint32, tag = "3")]
    pub nmpdjcmmckm: u32,
    #[prost(string, tag = "1806")]
    pub eoobpfjobbo: ::prost::alloc::string::String,
    #[prost(bool, tag = "1533")]
    pub unk15: bool,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ServerData {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub title: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub dispatch_url: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub env_type: ::prost::alloc::string::String,
    #[prost(string, tag = "5")]
    pub display_name: ::prost::alloc::string::String,
    #[prost(string, tag = "6")]
    pub msg: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GlobalDispatchData {
    #[prost(uint32, tag = "1")]
    pub retcode: u32,
    #[prost(string, tag = "2")]
    pub msg: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub top_sever_region_name: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "4")]
    pub server_list: ::prost::alloc::vec::Vec<ServerData>,
    #[prost(string, tag = "5")]
    pub stop_desc: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PlayerGetTokenCsReq {
    #[prost(uint32, tag = "3")]
    pub fclcccnbdlb: u32,
    #[prost(uint32, tag = "1")]
    pub uid: u32,
    #[prost(uint32, tag = "13")]
    pub platform: u32,
    #[prost(uint32, tag = "15")]
    pub aodjndcpdid: u32,
    #[prost(string, tag = "2")]
    pub account_uid_wrong: ::prost::alloc::string::String,
    #[prost(uint32, tag = "9")]
    pub ghkpbpdfijh: u32,
    #[prost(string, tag = "5")]
    pub account_uid: ::prost::alloc::string::String,
    #[prost(string, tag = "7")]
    pub token: ::prost::alloc::string::String,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct BlackInfo {
    #[prost(int64, tag = "1")]
    pub begin_time: i64,
    #[prost(int64, tag = "2")]
    pub end_time: i64,
    #[prost(uint32, tag = "3")]
    pub limit_level: u32,
    #[prost(uint32, tag = "4")]
    pub ban_type: u32,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PlayerGetTokenScRsp {
    #[prost(uint64, tag = "9")]
    pub secret_key_seed: u64,
    #[prost(message, optional, tag = "1")]
    pub black_info: ::core::option::Option<BlackInfo>,
    #[prost(uint32, tag = "15")]
    pub uid: u32,
    #[prost(string, tag = "14")]
    pub msg: ::prost::alloc::string::String,
    #[prost(uint32, tag = "11")]
    pub retcode: u32,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ExtraDeviceInfo {
    #[prost(string, tag = "1")]
    pub mmfbanghmhl: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub mdomlikdlih: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub jbocchafhlh: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub oeomjechnbi: ::prost::alloc::string::String,
    #[prost(string, tag = "5")]
    pub meiegkjddcb: ::prost::alloc::string::String,
    #[prost(string, tag = "6")]
    pub bhndmmdkfee: ::prost::alloc::string::String,
    #[prost(string, tag = "7")]
    pub mac: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PlayerLoginCsReq {
    #[prost(string, tag = "1040")]
    pub apejgcgcdnk: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub client_version: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub gehpjdmaeeo: ::prost::alloc::string::String,
    #[prost(string, tag = "13")]
    pub eaoiadcplni: ::prost::alloc::string::String,
    #[prost(uint32, tag = "6")]
    pub ejpgnpnmnme: u32,
    #[prost(string, tag = "450")]
    pub keckllnpnmc: ::prost::alloc::string::String,
    #[prost(string, tag = "10")]
    pub pggemchdkgm: ::prost::alloc::string::String,
    #[prost(string, tag = "8")]
    pub rogue_get_info: ::prost::alloc::string::String,
    #[prost(uint32, tag = "1261")]
    pub ghkpbpdfijh: u32,
    #[prost(string, tag = "15")]
    pub dmbaimcnhkk: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "1352")]
    pub hjbdiepmfcc: ::core::option::Option<ExtraDeviceInfo>,
    #[prost(uint64, tag = "5")]
    pub login_random: u64,
    #[prost(string, tag = "12")]
    pub mjbmnloijan: ::prost::alloc::string::String,
    #[prost(string, tag = "1933")]
    pub pdciladmjij: ::prost::alloc::string::String,
    #[prost(string, tag = "867")]
    pub aeohjingifk: ::prost::alloc::string::String,
    #[prost(string, tag = "1291")]
    pub bokafhimcen: ::prost::alloc::string::String,
    #[prost(string, tag = "11")]
    pub aalpfdjnhme: ::prost::alloc::string::String,
    #[prost(uint32, tag = "9")]
    pub client_res_version: u32,
    #[prost(string, tag = "1")]
    pub iacjlnhkfjl: ::prost::alloc::string::String,
    #[prost(uint32, tag = "1090")]
    pub mplbcokaihj: u32,
    #[prost(enumeration = "PlatformType", tag = "2")]
    pub platform: i32,
    #[prost(uint32, tag = "1000")]
    pub edibgljnojg: u32,
    #[prost(bool, tag = "170")]
    pub ncolnocggph: bool,
    #[prost(string, tag = "1640")]
    pub oohnmkaogcl: ::prost::alloc::string::String,
    #[prost(string, tag = "14")]
    pub signature: ::prost::alloc::string::String,
    #[prost(enumeration = "LanguageType", tag = "7")]
    pub dgdpjgplkhm: i32,
    #[prost(bool, tag = "304")]
    pub lnpeccbkbeb: bool,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PlayerBasicInfo {
    #[prost(string, tag = "1")]
    pub nickname: ::prost::alloc::string::String,
    #[prost(uint32, tag = "2")]
    pub level: u32,
    #[prost(uint32, tag = "3")]
    pub exp: u32,
    #[prost(uint32, tag = "4")]
    pub stamina: u32,
    #[prost(uint32, tag = "5")]
    pub mcoin: u32,
    #[prost(uint32, tag = "6")]
    pub hcoin: u32,
    #[prost(uint32, tag = "7")]
    pub scoin: u32,
    #[prost(uint32, tag = "8")]
    pub world_level: u32,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PlayerLoginScRsp {
    #[prost(uint64, tag = "7")]
    pub server_timestamp_ms: u64,
    #[prost(bool, tag = "2")]
    pub jddcochbnpg: bool,
    #[prost(bool, tag = "11")]
    pub goepmaljcmi: bool,
    #[prost(uint64, tag = "1")]
    pub login_random: u64,
    #[prost(uint32, tag = "6")]
    pub stamina: u32,
    #[prost(string, tag = "5")]
    pub lbfcfnidiae: ::prost::alloc::string::String,
    #[prost(uint32, tag = "13")]
    pub retcode: u32,
    #[prost(string, tag = "14")]
    pub gepmpieohim: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "10")]
    pub basic_info: ::core::option::Option<PlayerBasicInfo>,
    #[prost(int32, tag = "8")]
    pub cur_timezone: i32,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct PlayerLoginFinishCsReq {}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct PlayerLoginFinishScRsp {
    #[prost(uint32, tag = "14")]
    pub retcode: u32,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ClientUploadData {
    #[prost(string, tag = "1")]
    pub tag: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub value: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PlayerHeartBeatCsReq {
    #[prost(uint64, tag = "6")]
    pub client_time_ms: u64,
    #[prost(message, optional, tag = "14")]
    pub dopanlaafjf: ::core::option::Option<ClientUploadData>,
    #[prost(uint32, tag = "1")]
    pub bccloioaphm: u32,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ClientDownloadData {
    #[prost(uint32, tag = "1")]
    pub version: u32,
    #[prost(int64, tag = "2")]
    pub time: i64,
    /// uint32 ghkpbpdfijh = 4;
    #[prost(bytes = "vec", tag = "3")]
    pub data: ::prost::alloc::vec::Vec<u8>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PlayerHeartBeatScRsp {
    #[prost(uint64, tag = "1")]
    pub server_time_ms: u64,
    #[prost(uint64, tag = "8")]
    pub client_time_ms: u64,
    #[prost(uint32, tag = "15")]
    pub retcode: u32,
    #[prost(message, optional, tag = "12")]
    pub download_data: ::core::option::Option<ClientDownloadData>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GetBasicInfoCsReq {}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct PlayerSettingInfo {
    #[prost(bool, tag = "14")]
    pub ebephgldcnh: bool,
    #[prost(bool, tag = "13")]
    pub kmcckimhbbj: bool,
    #[prost(bool, tag = "15")]
    pub oigipmeoekb: bool,
    #[prost(bool, tag = "4")]
    pub kofdeoaglgk: bool,
    #[prost(bool, tag = "5")]
    pub kkhhcopengm: bool,
    #[prost(bool, tag = "6")]
    pub khkaapacgjf: bool,
    #[prost(bool, tag = "1")]
    pub efccddmnmlp: bool,
    #[prost(bool, tag = "8")]
    pub kmacdmafffn: bool,
    #[prost(bool, tag = "10")]
    pub meffkcapbfj: bool,
    #[prost(bool, tag = "12")]
    pub denfljkhnfo: bool,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GetBasicInfoScRsp {
    #[prost(uint32, tag = "10")]
    pub week_cocoon_finished_count: u32,
    #[prost(uint32, tag = "14")]
    pub gender: u32,
    #[prost(int64, tag = "6")]
    pub last_set_nickname_time: i64,
    #[prost(uint32, tag = "4")]
    pub cur_day: u32,
    #[prost(message, optional, tag = "15")]
    pub player_setting_info: ::core::option::Option<PlayerSettingInfo>,
    #[prost(int64, tag = "3")]
    pub next_recover_time: i64,
    #[prost(bool, tag = "8")]
    pub is_gender_set: bool,
    #[prost(uint32, tag = "5")]
    pub gameplay_birthday: u32,
    #[prost(uint32, tag = "2")]
    pub retcode: u32,
    #[prost(uint32, tag = "1")]
    pub exchange_times: u32,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetAvatarDataCsReq {
    #[prost(uint32, repeated, tag = "4")]
    pub base_avatar_id_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(bool, tag = "3")]
    pub is_get_all: bool,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct EquipRelic {
    #[prost(uint32, tag = "9")]
    pub r#type: u32,
    #[prost(uint32, tag = "2")]
    pub relic_unique_id: u32,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AvatarSkillTree {
    #[prost(uint32, tag = "1")]
    pub point_id: u32,
    #[prost(uint32, tag = "2")]
    pub level: u32,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Avatar {
    #[prost(uint64, tag = "7")]
    pub first_met_time_stamp: u64,
    #[prost(message, repeated, tag = "8")]
    pub equip_relic_list: ::prost::alloc::vec::Vec<EquipRelic>,
    #[prost(uint32, tag = "1")]
    pub exp: u32,
    #[prost(uint32, tag = "12")]
    pub equipment_unique_id: u32,
    #[prost(uint32, tag = "15")]
    pub rank: u32,
    #[prost(uint32, tag = "2")]
    pub level: u32,
    #[prost(message, repeated, tag = "4")]
    pub skilltree_list: ::prost::alloc::vec::Vec<AvatarSkillTree>,
    #[prost(bool, tag = "5")]
    pub is_marked: bool,
    #[prost(uint32, repeated, tag = "11")]
    pub has_taken_reward_level_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(uint32, tag = "13")]
    pub dressed_skin_id: u32,
    #[prost(uint32, tag = "14")]
    pub promotion: u32,
    #[prost(uint32, tag = "9")]
    pub base_avatar_id: u32,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetAvatarDataScRsp {
    #[prost(uint32, tag = "15")]
    pub pkmghnblipb: u32,
    #[prost(bool, tag = "5")]
    pub is_get_all: bool,
    #[prost(uint32, tag = "6")]
    pub retcode: u32,
    #[prost(uint32, repeated, tag = "10")]
    pub oicjbbphanb: ::prost::alloc::vec::Vec<u32>,
    #[prost(message, repeated, tag = "4")]
    pub avatar_list: ::prost::alloc::vec::Vec<Avatar>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GetMultiPathAvatarInfoCsReq {}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MultiPathAvatarInfo {
    #[prost(uint32, tag = "5")]
    pub rank: u32,
    #[prost(enumeration = "MultiPathAvatarType", tag = "3")]
    pub avatar_id: i32,
    #[prost(uint32, tag = "6")]
    pub path_equipment_id: u32,
    #[prost(message, repeated, tag = "13")]
    pub multi_path_skill_tree: ::prost::alloc::vec::Vec<AvatarSkillTree>,
    #[prost(message, repeated, tag = "9")]
    pub equip_relic_list: ::prost::alloc::vec::Vec<EquipRelic>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetMultiPathAvatarInfoScRsp {
    #[prost(uint32, tag = "9")]
    pub retcode: u32,
    #[prost(map = "uint32, enumeration(MultiPathAvatarType)", tag = "1")]
    pub cur_avatar_path: ::std::collections::HashMap<u32, i32>,
    #[prost(uint32, repeated, tag = "12")]
    pub basic_type_id_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(message, repeated, tag = "14")]
    pub multi_path_avatar_info_list: ::prost::alloc::vec::Vec<MultiPathAvatarInfo>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GetBagCsReq {}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct PileItem {
    #[prost(uint32, tag = "15")]
    pub item_num: u32,
    #[prost(uint32, tag = "12")]
    pub item_id: u32,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct Equipment {
    #[prost(uint32, tag = "9")]
    pub level: u32,
    #[prost(uint32, tag = "10")]
    pub equip_avatar_id: u32,
    #[prost(uint32, tag = "6")]
    pub tid: u32,
    #[prost(uint32, tag = "4")]
    pub exp: u32,
    #[prost(uint32, tag = "2")]
    pub promotion: u32,
    #[prost(uint32, tag = "12")]
    pub rank: u32,
    #[prost(uint32, tag = "1")]
    pub unique_id: u32,
    #[prost(bool, tag = "3")]
    pub is_protected: bool,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct Material0 {
    #[prost(uint64, tag = "9")]
    pub expire_time: u64,
    #[prost(uint32, tag = "14")]
    pub num: u32,
    #[prost(uint32, tag = "10")]
    pub tid: u32,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct Material {
    #[prost(uint64, tag = "7")]
    pub expire_time: u64,
    #[prost(uint32, tag = "14")]
    pub tid: u32,
    #[prost(uint32, tag = "6")]
    pub num: u32,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct RelicAffix {
    #[prost(uint32, tag = "1")]
    pub affix_id: u32,
    #[prost(uint32, tag = "2")]
    pub cnt: u32,
    #[prost(uint32, tag = "3")]
    pub step: u32,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Relic {
    #[prost(bool, tag = "10")]
    pub is_protected: bool,
    #[prost(message, repeated, tag = "9")]
    pub sub_affix_list: ::prost::alloc::vec::Vec<RelicAffix>,
    #[prost(uint32, tag = "7")]
    pub unique_id: u32,
    #[prost(message, repeated, tag = "15")]
    pub fnnglgifbbe: ::prost::alloc::vec::Vec<RelicAffix>,
    #[prost(uint32, tag = "4")]
    pub level: u32,
    #[prost(bool, tag = "6")]
    pub is_discarded: bool,
    #[prost(uint32, tag = "11")]
    pub exp: u32,
    #[prost(uint32, tag = "13")]
    pub tid: u32,
    #[prost(uint32, tag = "12")]
    pub main_affix_id: u32,
    #[prost(uint32, tag = "1")]
    pub equip_avatar_id: u32,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct WaitDelResource {
    #[prost(uint32, tag = "8")]
    pub num: u32,
    #[prost(uint32, tag = "3")]
    pub tid: u32,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetBagScRsp {
    #[prost(message, repeated, tag = "14")]
    pub mdcccjhgfkp: ::prost::alloc::vec::Vec<PileItem>,
    #[prost(message, repeated, tag = "2")]
    pub equipment_list: ::prost::alloc::vec::Vec<Equipment>,
    #[prost(uint32, tag = "9")]
    pub retcode: u32,
    #[prost(message, repeated, tag = "11")]
    pub bplaencojnn: ::prost::alloc::vec::Vec<Material0>,
    #[prost(message, repeated, tag = "10")]
    pub gamealbkaad: ::prost::alloc::vec::Vec<Material>,
    #[prost(message, repeated, tag = "4")]
    pub material_list: ::prost::alloc::vec::Vec<Material>,
    #[prost(message, repeated, tag = "3")]
    pub relic_list: ::prost::alloc::vec::Vec<Relic>,
    #[prost(message, repeated, tag = "13")]
    pub mokcdmcaknl: ::prost::alloc::vec::Vec<Material0>,
    #[prost(uint32, repeated, tag = "8")]
    pub dooakaaicfp: ::prost::alloc::vec::Vec<u32>,
    #[prost(uint32, tag = "5")]
    pub facgjdachom: u32,
    #[prost(message, repeated, tag = "15")]
    pub wait_del_resource_list: ::prost::alloc::vec::Vec<WaitDelResource>,
    #[prost(uint32, repeated, tag = "1")]
    pub bblohhgadgd: ::prost::alloc::vec::Vec<u32>,
    #[prost(enumeration = "TurnFoodSwitch", repeated, tag = "12")]
    pub admnoiakief: ::prost::alloc::vec::Vec<i32>,
    #[prost(uint32, repeated, tag = "6")]
    pub jldgljdhecb: ::prost::alloc::vec::Vec<u32>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetMissionStatusCsReq {
    #[prost(uint32, repeated, tag = "7")]
    pub mission_event_id_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(uint32, repeated, tag = "8")]
    pub main_mission_id_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(uint32, repeated, tag = "3")]
    pub sub_mission_id_list: ::prost::alloc::vec::Vec<u32>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MissionCustomValue {
    #[prost(uint32, tag = "7")]
    pub index: u32,
    #[prost(uint32, tag = "10")]
    pub custom_value: u32,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MissionCustomValueList {
    #[prost(message, repeated, tag = "2")]
    pub custom_value_list: ::prost::alloc::vec::Vec<MissionCustomValue>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MainMissionCustomValue {
    #[prost(uint32, tag = "4")]
    pub main_mission_id: u32,
    #[prost(message, optional, tag = "7")]
    pub custom_value_list: ::core::option::Option<MissionCustomValueList>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct Mission {
    #[prost(uint32, tag = "13")]
    pub id: u32,
    #[prost(uint32, tag = "4")]
    pub progress: u32,
    #[prost(enumeration = "MissionStatus", tag = "5")]
    pub status: i32,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetMissionStatusScRsp {
    #[prost(uint32, repeated, tag = "7")]
    pub disabled_main_mission_id_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(uint32, tag = "6")]
    pub retcode: u32,
    #[prost(message, repeated, tag = "12")]
    pub main_mission_mcv_list: ::prost::alloc::vec::Vec<MainMissionCustomValue>,
    #[prost(uint32, repeated, tag = "3")]
    pub unfinished_main_mission_id_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(message, repeated, tag = "1")]
    pub mission_event_status_list: ::prost::alloc::vec::Vec<Mission>,
    #[prost(uint32, repeated, tag = "13")]
    pub finished_main_mission_id_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(message, repeated, tag = "9")]
    pub sub_mission_status_list: ::prost::alloc::vec::Vec<Mission>,
    #[prost(uint32, repeated, tag = "15")]
    pub curversion_finished_main_mission_id_list: ::prost::alloc::vec::Vec<u32>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AmountInfo {
    #[prost(uint32, tag = "1")]
    pub cur_amount: u32,
    #[prost(uint32, tag = "2")]
    pub max_amount: u32,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct LineupAvatar {
    #[prost(uint32, tag = "3")]
    pub id: u32,
    #[prost(uint32, tag = "4")]
    pub slot_type: u32,
    #[prost(uint32, tag = "14")]
    pub hp: u32,
    #[prost(message, optional, tag = "10")]
    pub sp: ::core::option::Option<AmountInfo>,
    #[prost(uint32, tag = "6")]
    pub satiety: u32,
    #[prost(enumeration = "AvatarType", tag = "8")]
    pub avatar_type: i32,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LineupInfo {
    #[prost(bool, tag = "6")]
    pub pjbjnfnbjon: bool,
    #[prost(uint32, repeated, tag = "10")]
    pub jnmdgcjhcjj: ::prost::alloc::vec::Vec<u32>,
    #[prost(uint32, repeated, tag = "8")]
    pub iddndgkoilc: ::prost::alloc::vec::Vec<u32>,
    #[prost(uint32, tag = "5")]
    pub index: u32,
    #[prost(uint32, tag = "7")]
    pub plane_id: u32,
    #[prost(uint32, tag = "13")]
    pub game_story_line_id: u32,
    #[prost(uint32, repeated, tag = "11")]
    pub omagmokjhnm: ::prost::alloc::vec::Vec<u32>,
    #[prost(bool, tag = "1")]
    pub is_virtual: bool,
    #[prost(enumeration = "ExtraLineupType", tag = "14")]
    pub extra_lineup_type: i32,
    #[prost(uint32, tag = "12")]
    pub leader_slot: u32,
    #[prost(uint32, tag = "3")]
    pub mp: u32,
    #[prost(string, tag = "15")]
    pub name: ::prost::alloc::string::String,
    #[prost(uint32, tag = "9")]
    pub max_mp: u32,
    #[prost(message, repeated, tag = "4")]
    pub avatar_list: ::prost::alloc::vec::Vec<LineupAvatar>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GetCurLineupDataCsReq {}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetCurLineupDataScRsp {
    #[prost(message, optional, tag = "3")]
    pub lineup: ::core::option::Option<LineupInfo>,
    #[prost(uint32, tag = "7")]
    pub retcode: u32,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GetAllLineupDataCsReq {}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetAllLineupDataScRsp {
    #[prost(uint32, tag = "12")]
    pub retcode: u32,
    #[prost(uint32, tag = "1")]
    pub cur_index: u32,
    #[prost(message, repeated, tag = "8")]
    pub lineup_list: ::prost::alloc::vec::Vec<LineupInfo>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GetCurSceneInfoCsReq {}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SceneActorInfo {
    #[prost(uint32, tag = "2")]
    pub map_layer: u32,
    #[prost(uint32, tag = "14")]
    pub uid: u32,
    #[prost(enumeration = "AvatarType", tag = "5")]
    pub avatar_type: i32,
    #[prost(uint32, tag = "8")]
    pub base_avatar_id: u32,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Hnebcfcdmpc {
    #[prost(bool, tag = "10")]
    pub bbcnhcejfbp: bool,
    #[prost(uint32, tag = "4")]
    pub efdiadoejob: u32,
    #[prost(bytes = "vec", tag = "9")]
    pub hbblkjgckpf: ::prost::alloc::vec::Vec<u8>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ScenePropInfo {
    /// PropExtraInfo extra_info = 10;
    #[prost(uint32, tag = "11")]
    pub prop_state: u32,
    #[prost(message, optional, tag = "13")]
    pub hmgcoanonll: ::core::option::Option<Hnebcfcdmpc>,
    #[prost(uint32, tag = "3")]
    pub prop_id: u32,
    #[prost(uint32, tag = "2")]
    pub life_time_ms: u32,
    #[prost(uint64, tag = "9")]
    pub create_time_ms: u64,
    #[prost(string, repeated, tag = "4")]
    pub trigger_name_list: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct Vector {
    #[prost(sint32, tag = "7")]
    pub y: i32,
    #[prost(sint32, tag = "3")]
    pub z: i32,
    #[prost(sint32, tag = "6")]
    pub x: i32,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MotionInfo {
    #[prost(message, optional, tag = "11")]
    pub rot: ::core::option::Option<Vector>,
    #[prost(message, optional, tag = "12")]
    pub pos: ::core::option::Option<Vector>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SceneEntityInfo {
    #[prost(message, optional, tag = "11")]
    pub actor: ::core::option::Option<SceneActorInfo>,
    /// SceneNpcMonsterInfo npc_monster = 9;
    /// SceneNpcInfo npc = 13;
    #[prost(message, optional, tag = "7")]
    pub prop: ::core::option::Option<ScenePropInfo>,
    /// SceneSummonUnitInfo summon_unit = 4;
    #[prost(uint32, tag = "2")]
    pub entity_id: u32,
    #[prost(uint32, tag = "14")]
    pub group_id: u32,
    #[prost(uint32, tag = "6")]
    pub inst_id: u32,
    #[prost(message, optional, tag = "10")]
    pub motion: ::core::option::Option<MotionInfo>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SceneGroupInfo {
    /// map<string, int32> gbnnlkibhon = 9;
    #[prost(uint32, tag = "13")]
    pub group_id: u32,
    #[prost(message, repeated, tag = "10")]
    pub entity_list: ::prost::alloc::vec::Vec<SceneEntityInfo>,
    #[prost(uint32, tag = "8")]
    pub state: u32,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct Dlibjafbhea {
    #[prost(uint32, tag = "2")]
    pub hichlooflbd: u32,
    #[prost(uint32, tag = "15")]
    pub pbiablpekob: u32,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ClientGroupInfo {
    #[prost(uint32, tag = "10")]
    pub group_id: u32,
    #[prost(bool, tag = "9")]
    pub is_default: bool,
    #[prost(uint32, tag = "12")]
    pub state: u32,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SceneInfo {
    #[prost(uint32, tag = "9")]
    pub game_mode_type: u32,
    /// uint32 world_id = 5;
    #[prost(message, repeated, tag = "1301")]
    pub scene_group_list: ::prost::alloc::vec::Vec<SceneGroupInfo>,
    #[prost(uint32, tag = "27")]
    pub game_story_line_id: u32,
    #[prost(uint32, tag = "14")]
    pub entry_id: u32,
    /// repeated EntityBuffInfo entity_buff_info_list = 8;
    #[prost(message, repeated, tag = "4")]
    pub entity_list: ::prost::alloc::vec::Vec<SceneEntityInfo>,
    #[prost(uint32, tag = "11")]
    pub leader_entity_id: u32,
    #[prost(uint32, tag = "10")]
    pub plane_id: u32,
    /// repeated CustomSaveData custom_data_list = 13;
    /// repeated BuffInfo scene_buff_info_list = 2;
    /// MissionStatusBySceneInfo scene_mission_info = 1039;
    #[prost(uint32, tag = "1348")]
    pub content_id: u32,
    #[prost(uint32, tag = "1130")]
    pub dimension_id: u32,
    #[prost(map = "string, int32", tag = "1313")]
    pub floor_saved_data: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        i32,
    >,
    /// uint32 world_id = 9;
    #[prost(map = "uint32, message", tag = "15")]
    pub fhlamihooja: ::std::collections::HashMap<u32, Dlibjafbhea>,
    #[prost(uint32, repeated, tag = "1")]
    pub lighten_section_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(uint32, tag = "6")]
    pub default_pos: u32,
    #[prost(uint32, tag = "7")]
    pub floor_id: u32,
    #[prost(message, repeated, tag = "1512")]
    pub client_group_list: ::prost::alloc::vec::Vec<ClientGroupInfo>,
    #[prost(uint32, repeated, tag = "1064")]
    pub mglhebhjabe: ::prost::alloc::vec::Vec<u32>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetCurSceneInfoScRsp {
    #[prost(message, optional, tag = "1")]
    pub scene: ::core::option::Option<SceneInfo>,
    #[prost(uint32, tag = "11")]
    pub retcode: u32,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct PveBattleResultCsReq {
    #[prost(uint32, tag = "6")]
    pub stage_id: u32,
    #[prost(uint32, tag = "2")]
    pub battle_id: u32,
    #[prost(enumeration = "BattleEndStatus", tag = "13")]
    pub end_status: i32,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct BattleEquipment {
    #[prost(uint32, tag = "1")]
    pub id: u32,
    #[prost(uint32, tag = "2")]
    pub level: u32,
    #[prost(uint32, tag = "3")]
    pub promotion: u32,
    #[prost(uint32, tag = "4")]
    pub rank: u32,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BattleRelic {
    #[prost(uint32, tag = "1")]
    pub id: u32,
    #[prost(uint32, tag = "2")]
    pub level: u32,
    #[prost(uint32, tag = "3")]
    pub main_affix_id: u32,
    #[prost(message, repeated, tag = "4")]
    pub sub_affix_list: ::prost::alloc::vec::Vec<RelicAffix>,
    #[prost(uint32, tag = "5")]
    pub unique_id: u32,
    #[prost(uint32, tag = "6")]
    pub set_id: u32,
    #[prost(uint32, tag = "7")]
    pub r#type: u32,
    #[prost(uint32, tag = "8")]
    pub rarity: u32,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Ephioeimepb {
    #[prost(bool, tag = "1")]
    pub apjgenoipnb: bool,
    #[prost(uint32, repeated, tag = "2")]
    pub hbcpoddmcpo: ::prost::alloc::vec::Vec<u32>,
    #[prost(uint32, tag = "3")]
    pub ojkjhgejlek: u32,
    #[prost(uint32, tag = "4")]
    pub lejnkcjgbec: u32,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BattleAvatar {
    #[prost(enumeration = "AvatarType", tag = "1")]
    pub avatar_type: i32,
    #[prost(uint32, tag = "2")]
    pub id: u32,
    #[prost(uint32, tag = "3")]
    pub level: u32,
    #[prost(uint32, tag = "4")]
    pub rank: u32,
    #[prost(uint32, tag = "5")]
    pub index: u32,
    #[prost(message, repeated, tag = "6")]
    pub skilltree_list: ::prost::alloc::vec::Vec<AvatarSkillTree>,
    #[prost(message, repeated, tag = "7")]
    pub equipment_list: ::prost::alloc::vec::Vec<BattleEquipment>,
    #[prost(uint32, tag = "8")]
    pub hp: u32,
    #[prost(uint32, tag = "10")]
    pub promotion: u32,
    #[prost(message, repeated, tag = "11")]
    pub relic_list: ::prost::alloc::vec::Vec<BattleRelic>,
    #[prost(uint32, tag = "12")]
    pub world_level: u32,
    #[prost(uint32, tag = "13")]
    pub assist_uid: u32,
    #[prost(message, optional, tag = "15")]
    pub nlcjclfgmin: ::core::option::Option<Ephioeimepb>,
    #[prost(message, optional, tag = "16")]
    pub sp: ::core::option::Option<AmountInfo>,
    #[prost(uint32, tag = "17")]
    pub pgijnibedfo: u32,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct Item {
    #[prost(uint32, tag = "14")]
    pub main_affix_id: u32,
    #[prost(uint32, tag = "7")]
    pub promotion: u32,
    #[prost(uint32, tag = "13")]
    pub unique_id: u32,
    #[prost(uint32, tag = "8")]
    pub level: u32,
    #[prost(uint32, tag = "9")]
    pub item_id: u32,
    #[prost(uint32, tag = "15")]
    pub num: u32,
    #[prost(uint32, tag = "2")]
    pub rank: u32,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ItemList {
    #[prost(message, repeated, tag = "4")]
    pub item_list: ::prost::alloc::vec::Vec<Item>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PveBattleResultScRsp {
    #[prost(string, tag = "15")]
    pub clebbkoiohj: ::prost::alloc::string::String,
    #[prost(uint32, tag = "14")]
    pub retcode: u32,
    #[prost(enumeration = "BattleEndStatus", tag = "1")]
    pub end_status: i32,
    #[prost(uint32, tag = "10")]
    pub event_id: u32,
    #[prost(bool, tag = "4")]
    pub mfjljkcmiol: bool,
    #[prost(uint32, tag = "9")]
    pub gcmfmldnldm: u32,
    #[prost(uint32, tag = "3")]
    pub mismatch_turn_count: u32,
    #[prost(uint32, tag = "5")]
    pub battle_id: u32,
    #[prost(message, optional, tag = "8")]
    pub ieinoefbllp: ::core::option::Option<ItemList>,
    #[prost(uint32, tag = "6")]
    pub stage_id: u32,
    #[prost(message, repeated, tag = "7")]
    pub battle_avatar_list: ::prost::alloc::vec::Vec<BattleAvatar>,
    #[prost(string, tag = "12")]
    pub lfhbhkhmned: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "1392")]
    pub ifjljadpfdg: ::core::option::Option<ItemList>,
    #[prost(uint32, tag = "13")]
    pub njghcpijdgi: u32,
    #[prost(message, optional, tag = "2")]
    pub cllokodkpap: ::core::option::Option<ItemList>,
    #[prost(message, optional, tag = "11")]
    pub eebbmnlacmg: ::core::option::Option<ItemList>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct StartCocoonStageCsReq {
    #[prost(uint32, tag = "13")]
    pub prop_entity_id: u32,
    #[prost(uint32, tag = "15")]
    pub world_level: u32,
    #[prost(uint32, tag = "1")]
    pub wave: u32,
    #[prost(uint32, tag = "9")]
    pub cocoon_id: u32,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BattleBuff {
    #[prost(uint32, tag = "1")]
    pub id: u32,
    #[prost(uint32, tag = "2")]
    pub level: u32,
    #[prost(uint32, tag = "3")]
    pub owner_index: u32,
    #[prost(uint32, tag = "4")]
    pub wave_flag: u32,
    #[prost(uint32, repeated, tag = "5")]
    pub target_index_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(map = "string, float", tag = "6")]
    pub dynamic_values: ::std::collections::HashMap<::prost::alloc::string::String, f32>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SceneMonsterData {
    #[prost(uint32, tag = "13")]
    pub cur_hp: u32,
    #[prost(uint32, tag = "14")]
    pub max_hp: u32,
    #[prost(uint32, tag = "15")]
    pub monster_id: u32,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SceneMonsterWaveParam {
    #[prost(uint32, tag = "10")]
    pub level: u32,
    #[prost(uint32, tag = "2")]
    pub elite_group: u32,
    #[prost(uint32, tag = "5")]
    pub cbiaoplipkj: u32,
    #[prost(uint32, tag = "13")]
    pub hard_level_group: u32,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SceneMonsterWave {
    #[prost(message, repeated, tag = "3")]
    pub olfgemadaco: ::prost::alloc::vec::Vec<ItemList>,
    #[prost(uint32, tag = "5")]
    pub battle_wave_id: u32,
    #[prost(message, repeated, tag = "1")]
    pub monster_list: ::prost::alloc::vec::Vec<SceneMonsterData>,
    #[prost(uint32, tag = "15")]
    pub battle_stage_id: u32,
    #[prost(message, optional, tag = "11")]
    pub wave_param: ::core::option::Option<SceneMonsterWaveParam>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SceneBattleInfo {
    #[prost(uint32, tag = "1")]
    pub world_level: u32,
    /// repeated BattleEventBattleInfo battle_event = 928;
    #[prost(message, repeated, tag = "13")]
    pub buff_list: ::prost::alloc::vec::Vec<BattleBuff>,
    /// EvolveBuildBattleInfo adafaohflma = 1079;
    #[prost(bool, tag = "3")]
    pub nbgogjjojma: bool,
    #[prost(uint32, tag = "9")]
    pub battle_id: u32,
    #[prost(uint32, tag = "15")]
    pub stage_id: u32,
    #[prost(uint32, tag = "14")]
    pub cycle_count: u32,
    #[prost(message, repeated, tag = "4")]
    pub monster_wave_list: ::prost::alloc::vec::Vec<SceneMonsterWave>,
    /// BattleRogueMagicInfo battle_rogue_magic_info = 1993;
    #[prost(message, repeated, tag = "10")]
    pub battle_avatar_list: ::prost::alloc::vec::Vec<BattleAvatar>,
    /// OLGKJDLMEIO gddalcgoobg = 796;
    /// map<uint32, BattleTargetList> battle_target_info = 1840;
    #[prost(uint32, tag = "12")]
    pub logic_random_seed: u32,
    /// NMKAECDMHOP igpipnaaebj = 1824;
    #[prost(uint32, tag = "5")]
    pub makigfemknm: u32,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StartCocoonStageScRsp {
    #[prost(message, optional, tag = "2")]
    pub battle_info: ::core::option::Option<SceneBattleInfo>,
    #[prost(uint32, tag = "5")]
    pub cocoon_id: u32,
    #[prost(uint32, tag = "11")]
    pub prop_entity_id: u32,
    #[prost(uint32, tag = "10")]
    pub wave: u32,
    #[prost(uint32, tag = "6")]
    pub retcode: u32,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct EntityMotion {
    #[prost(bool, tag = "14")]
    pub kkbdjdlhmkf: bool,
    #[prost(uint32, tag = "4")]
    pub map_layer: u32,
    #[prost(uint32, tag = "2")]
    pub entity_id: u32,
    #[prost(message, optional, tag = "11")]
    pub motion: ::core::option::Option<MotionInfo>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SceneEntityMoveCsReq {
    #[prost(uint32, tag = "8")]
    pub entry_id: u32,
    #[prost(uint64, tag = "15")]
    pub dcmncgdjobj: u64,
    #[prost(message, repeated, tag = "9")]
    pub entity_motion_list: ::prost::alloc::vec::Vec<EntityMotion>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SceneEntityMoveScRsp {
    #[prost(message, repeated, tag = "11")]
    pub entity_motion_list: ::prost::alloc::vec::Vec<EntityMotion>,
    #[prost(message, optional, tag = "7")]
    pub download_data: ::core::option::Option<ClientDownloadData>,
    #[prost(uint32, tag = "8")]
    pub retcode: u32,
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum PlatformType {
    Editor = 0,
    Ios = 1,
    Android = 2,
    Pc = 3,
    Web = 4,
    Wap = 5,
    Ps4 = 6,
    Nintendo = 7,
    CloudAndroid = 8,
    CloudPc = 9,
    CloudIos = 10,
    Ps5 = 11,
    Mac = 12,
    CloudMac = 13,
    CloudWebAndroid = 20,
    CloudWebIos = 21,
    CloudWebPc = 22,
    CloudWebMac = 23,
    CloudWebTouch = 24,
    CloudWebKeyboard = 25,
}
impl PlatformType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Editor => "EDITOR",
            Self::Ios => "IOS",
            Self::Android => "ANDROID",
            Self::Pc => "PC",
            Self::Web => "WEB",
            Self::Wap => "WAP",
            Self::Ps4 => "PS4",
            Self::Nintendo => "NINTENDO",
            Self::CloudAndroid => "CLOUD_ANDROID",
            Self::CloudPc => "CLOUD_PC",
            Self::CloudIos => "CLOUD_IOS",
            Self::Ps5 => "PS5",
            Self::Mac => "MAC",
            Self::CloudMac => "CLOUD_MAC",
            Self::CloudWebAndroid => "CLOUD_WEB_ANDROID",
            Self::CloudWebIos => "CLOUD_WEB_IOS",
            Self::CloudWebPc => "CLOUD_WEB_PC",
            Self::CloudWebMac => "CLOUD_WEB_MAC",
            Self::CloudWebTouch => "CLOUD_WEB_TOUCH",
            Self::CloudWebKeyboard => "CLOUD_WEB_KEYBOARD",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "EDITOR" => Some(Self::Editor),
            "IOS" => Some(Self::Ios),
            "ANDROID" => Some(Self::Android),
            "PC" => Some(Self::Pc),
            "WEB" => Some(Self::Web),
            "WAP" => Some(Self::Wap),
            "PS4" => Some(Self::Ps4),
            "NINTENDO" => Some(Self::Nintendo),
            "CLOUD_ANDROID" => Some(Self::CloudAndroid),
            "CLOUD_PC" => Some(Self::CloudPc),
            "CLOUD_IOS" => Some(Self::CloudIos),
            "PS5" => Some(Self::Ps5),
            "MAC" => Some(Self::Mac),
            "CLOUD_MAC" => Some(Self::CloudMac),
            "CLOUD_WEB_ANDROID" => Some(Self::CloudWebAndroid),
            "CLOUD_WEB_IOS" => Some(Self::CloudWebIos),
            "CLOUD_WEB_PC" => Some(Self::CloudWebPc),
            "CLOUD_WEB_MAC" => Some(Self::CloudWebMac),
            "CLOUD_WEB_TOUCH" => Some(Self::CloudWebTouch),
            "CLOUD_WEB_KEYBOARD" => Some(Self::CloudWebKeyboard),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum LanguageType {
    LanguageNone = 0,
    LanguageSc = 1,
    LanguageTc = 2,
    LanguageEn = 3,
    LanguageKr = 4,
    LanguageJp = 5,
    LanguageFr = 6,
    LanguageDe = 7,
    LanguageEs = 8,
    LanguagePt = 9,
    LanguageRu = 10,
    LanguageTh = 11,
    LanguageVi = 12,
    LanguageId = 13,
}
impl LanguageType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::LanguageNone => "LANGUAGE_NONE",
            Self::LanguageSc => "LANGUAGE_SC",
            Self::LanguageTc => "LANGUAGE_TC",
            Self::LanguageEn => "LANGUAGE_EN",
            Self::LanguageKr => "LANGUAGE_KR",
            Self::LanguageJp => "LANGUAGE_JP",
            Self::LanguageFr => "LANGUAGE_FR",
            Self::LanguageDe => "LANGUAGE_DE",
            Self::LanguageEs => "LANGUAGE_ES",
            Self::LanguagePt => "LANGUAGE_PT",
            Self::LanguageRu => "LANGUAGE_RU",
            Self::LanguageTh => "LANGUAGE_TH",
            Self::LanguageVi => "LANGUAGE_VI",
            Self::LanguageId => "LANGUAGE_ID",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "LANGUAGE_NONE" => Some(Self::LanguageNone),
            "LANGUAGE_SC" => Some(Self::LanguageSc),
            "LANGUAGE_TC" => Some(Self::LanguageTc),
            "LANGUAGE_EN" => Some(Self::LanguageEn),
            "LANGUAGE_KR" => Some(Self::LanguageKr),
            "LANGUAGE_JP" => Some(Self::LanguageJp),
            "LANGUAGE_FR" => Some(Self::LanguageFr),
            "LANGUAGE_DE" => Some(Self::LanguageDe),
            "LANGUAGE_ES" => Some(Self::LanguageEs),
            "LANGUAGE_PT" => Some(Self::LanguagePt),
            "LANGUAGE_RU" => Some(Self::LanguageRu),
            "LANGUAGE_TH" => Some(Self::LanguageTh),
            "LANGUAGE_VI" => Some(Self::LanguageVi),
            "LANGUAGE_ID" => Some(Self::LanguageId),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum MultiPathAvatarType {
    None = 0,
    Mar7thKnightType = 1001,
    Mar7thRogueType = 1224,
    BoyWarriorType = 8001,
    GirlWarriorType = 8002,
    BoyKnightType = 8003,
    GirlKnightType = 8004,
    BoyShamanType = 8005,
    GirlShamanType = 8006,
    BoyMemoryType = 8007,
    GirlMemoryType = 8008,
}
impl MultiPathAvatarType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::None => "MultiPathAvatarTypeNone",
            Self::Mar7thKnightType => "Mar_7thKnightType",
            Self::Mar7thRogueType => "Mar_7thRogueType",
            Self::BoyWarriorType => "BoyWarriorType",
            Self::GirlWarriorType => "GirlWarriorType",
            Self::BoyKnightType => "BoyKnightType",
            Self::GirlKnightType => "GirlKnightType",
            Self::BoyShamanType => "BoyShamanType",
            Self::GirlShamanType => "GirlShamanType",
            Self::BoyMemoryType => "BoyMemoryType",
            Self::GirlMemoryType => "GirlMemoryType",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "MultiPathAvatarTypeNone" => Some(Self::None),
            "Mar_7thKnightType" => Some(Self::Mar7thKnightType),
            "Mar_7thRogueType" => Some(Self::Mar7thRogueType),
            "BoyWarriorType" => Some(Self::BoyWarriorType),
            "GirlWarriorType" => Some(Self::GirlWarriorType),
            "BoyKnightType" => Some(Self::BoyKnightType),
            "GirlKnightType" => Some(Self::GirlKnightType),
            "BoyShamanType" => Some(Self::BoyShamanType),
            "GirlShamanType" => Some(Self::GirlShamanType),
            "BoyMemoryType" => Some(Self::BoyMemoryType),
            "GirlMemoryType" => Some(Self::GirlMemoryType),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum TurnFoodSwitch {
    None = 0,
    Attack = 1,
    Define = 2,
}
impl TurnFoodSwitch {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::None => "TURN_FOOD_SWITCH_NONE",
            Self::Attack => "TURN_FOOD_SWITCH_ATTACK",
            Self::Define => "TURN_FOOD_SWITCH_DEFINE",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "TURN_FOOD_SWITCH_NONE" => Some(Self::None),
            "TURN_FOOD_SWITCH_ATTACK" => Some(Self::Attack),
            "TURN_FOOD_SWITCH_DEFINE" => Some(Self::Define),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum MissionStatus {
    MissionNone = 0,
    MissionDoing = 1,
    MissionFinish = 2,
    MissionPrepared = 3,
}
impl MissionStatus {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::MissionNone => "MISSION_NONE",
            Self::MissionDoing => "MISSION_DOING",
            Self::MissionFinish => "MISSION_FINISH",
            Self::MissionPrepared => "MISSION_PREPARED",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "MISSION_NONE" => Some(Self::MissionNone),
            "MISSION_DOING" => Some(Self::MissionDoing),
            "MISSION_FINISH" => Some(Self::MissionFinish),
            "MISSION_PREPARED" => Some(Self::MissionPrepared),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ExtraLineupType {
    LineupNone = 0,
    LineupChallenge = 1,
    LineupRogue = 2,
    LineupChallenge2 = 3,
    LineupChallenge3 = 4,
    LineupRogueChallenge = 5,
    LineupStageTrial = 6,
    LineupRogueTrial = 7,
    LineupActivity = 8,
    LineupBoxingClub = 9,
    LineupTreasureDungeon = 11,
    LineupChessRogue = 12,
    LineupHeliobus = 13,
    LineupTournRogue = 14,
    LineupRelicRogue = 15,
    LineupArcadeRogue = 16,
    LineupMagicRogue = 17,
}
impl ExtraLineupType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::LineupNone => "LINEUP_NONE",
            Self::LineupChallenge => "LINEUP_CHALLENGE",
            Self::LineupRogue => "LINEUP_ROGUE",
            Self::LineupChallenge2 => "LINEUP_CHALLENGE_2",
            Self::LineupChallenge3 => "LINEUP_CHALLENGE_3",
            Self::LineupRogueChallenge => "LINEUP_ROGUE_CHALLENGE",
            Self::LineupStageTrial => "LINEUP_STAGE_TRIAL",
            Self::LineupRogueTrial => "LINEUP_ROGUE_TRIAL",
            Self::LineupActivity => "LINEUP_ACTIVITY",
            Self::LineupBoxingClub => "LINEUP_BOXING_CLUB",
            Self::LineupTreasureDungeon => "LINEUP_TREASURE_DUNGEON",
            Self::LineupChessRogue => "LINEUP_CHESS_ROGUE",
            Self::LineupHeliobus => "LINEUP_HELIOBUS",
            Self::LineupTournRogue => "LINEUP_TOURN_ROGUE",
            Self::LineupRelicRogue => "LINEUP_RELIC_ROGUE",
            Self::LineupArcadeRogue => "LINEUP_ARCADE_ROGUE",
            Self::LineupMagicRogue => "LINEUP_MAGIC_ROGUE",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "LINEUP_NONE" => Some(Self::LineupNone),
            "LINEUP_CHALLENGE" => Some(Self::LineupChallenge),
            "LINEUP_ROGUE" => Some(Self::LineupRogue),
            "LINEUP_CHALLENGE_2" => Some(Self::LineupChallenge2),
            "LINEUP_CHALLENGE_3" => Some(Self::LineupChallenge3),
            "LINEUP_ROGUE_CHALLENGE" => Some(Self::LineupRogueChallenge),
            "LINEUP_STAGE_TRIAL" => Some(Self::LineupStageTrial),
            "LINEUP_ROGUE_TRIAL" => Some(Self::LineupRogueTrial),
            "LINEUP_ACTIVITY" => Some(Self::LineupActivity),
            "LINEUP_BOXING_CLUB" => Some(Self::LineupBoxingClub),
            "LINEUP_TREASURE_DUNGEON" => Some(Self::LineupTreasureDungeon),
            "LINEUP_CHESS_ROGUE" => Some(Self::LineupChessRogue),
            "LINEUP_HELIOBUS" => Some(Self::LineupHeliobus),
            "LINEUP_TOURN_ROGUE" => Some(Self::LineupTournRogue),
            "LINEUP_RELIC_ROGUE" => Some(Self::LineupRelicRogue),
            "LINEUP_ARCADE_ROGUE" => Some(Self::LineupArcadeRogue),
            "LINEUP_MAGIC_ROGUE" => Some(Self::LineupMagicRogue),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum AvatarType {
    None = 0,
    AvatarTrialType = 1,
    AvatarLimitType = 2,
    AvatarFormalType = 3,
    AvatarAssistType = 4,
    AvatarAetherDivideType = 5,
    AvatarUpgradeAvailableType = 6,
}
impl AvatarType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::None => "AVATAR_TYPE_NONE",
            Self::AvatarTrialType => "AVATAR_TRIAL_TYPE",
            Self::AvatarLimitType => "AVATAR_LIMIT_TYPE",
            Self::AvatarFormalType => "AVATAR_FORMAL_TYPE",
            Self::AvatarAssistType => "AVATAR_ASSIST_TYPE",
            Self::AvatarAetherDivideType => "AVATAR_AETHER_DIVIDE_TYPE",
            Self::AvatarUpgradeAvailableType => "AVATAR_UPGRADE_AVAILABLE_TYPE",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "AVATAR_TYPE_NONE" => Some(Self::None),
            "AVATAR_TRIAL_TYPE" => Some(Self::AvatarTrialType),
            "AVATAR_LIMIT_TYPE" => Some(Self::AvatarLimitType),
            "AVATAR_FORMAL_TYPE" => Some(Self::AvatarFormalType),
            "AVATAR_ASSIST_TYPE" => Some(Self::AvatarAssistType),
            "AVATAR_AETHER_DIVIDE_TYPE" => Some(Self::AvatarAetherDivideType),
            "AVATAR_UPGRADE_AVAILABLE_TYPE" => Some(Self::AvatarUpgradeAvailableType),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum BattleEndStatus {
    BattleEndNone = 0,
    BattleEndWin = 1,
    BattleEndLose = 2,
    BattleEndQuit = 3,
}
impl BattleEndStatus {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::BattleEndNone => "BATTLE_END_NONE",
            Self::BattleEndWin => "BATTLE_END_WIN",
            Self::BattleEndLose => "BATTLE_END_LOSE",
            Self::BattleEndQuit => "BATTLE_END_QUIT",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "BATTLE_END_NONE" => Some(Self::BattleEndNone),
            "BATTLE_END_WIN" => Some(Self::BattleEndWin),
            "BATTLE_END_LOSE" => Some(Self::BattleEndLose),
            "BATTLE_END_QUIT" => Some(Self::BattleEndQuit),
            _ => None,
        }
    }
}
